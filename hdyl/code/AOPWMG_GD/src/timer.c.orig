#include "timer.h"
#include "filter.h"

TIM_HandleTypeDef TIM3_Handler;         //定时器5句柄

//定时器5通道1输入捕获配置
//arr：自动重装值(TIM2,TIM5是32位的!!)
//psc：时钟预分频数
void TIM3_CH3_Cap_Init(uint32_t arr,unsigned int psc)
{
    TIM_IC_InitTypeDef TIM3_CH33Config;

    TIM3_Handler.Instance=TIM3;                          //通用定时器5
    TIM3_Handler.Init.Prescaler=psc;                     //分频系数
    TIM3_Handler.Init.CounterMode=TIM_COUNTERMODE_UP;    //向上计数器
    TIM3_Handler.Init.Period=arr;                        //自动装载值
    TIM3_Handler.Init.ClockDivision=TIM_CLOCKDIVISION_DIV1;//时钟分频银子
    HAL_TIM_IC_Init(&TIM3_Handler);//初始化输入捕获时基参数

    TIM3_CH33Config.ICPolarity=TIM_ICPOLARITY_RISING;    //上升沿捕获
    TIM3_CH33Config.ICSelection=TIM_ICSELECTION_DIRECTTI;//映射到TI1上
    TIM3_CH33Config.ICPrescaler=TIM_ICPSC_DIV1;          //配置输入分频，不分频
    TIM3_CH33Config.ICFilter=0;                          //配置输入滤波器，不滤波
    HAL_TIM_IC_ConfigChannel(&TIM3_Handler,&TIM3_CH33Config,TIM_CHANNEL_3);//配置TIM5通道1

    HAL_TIM_IC_Start_IT(&TIM3_Handler,TIM_CHANNEL_3);   //开启TIM3的捕获通道3，并且开启捕获中断
    __HAL_TIM_ENABLE_IT(&TIM3_Handler,TIM_IT_UPDATE);   //使能更新中断
}



//捕获状态
//[7]:0,没有成功的捕获;1,成功捕获到一次.
//[6]:0,还没捕获到低电平;1,已经捕获到低电平了.
//[5:0]:捕获低电平后溢出的次数(对于32位定时器来说,1us计数器加1,溢出时间:4294秒)
unsigned char  TIM3CH3_CAPTURE_STA=0;	//输入捕获状态
uint32_t	TIM3CH3_CAPTURE_VAL;	//输入捕获值(TIM2/TIM5是32位)


//定时器5中断服务函数
void TIM3_IRQHandler(void)
{
    HAL_TIM_IRQHandler(&TIM3_Handler);//定时器共用处理函数
}



//定时器更新中断（计数溢出）中断处理回调函数， 该函数在HAL_TIM_IRQHandler中会被调用
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)//更新中断（溢出）发生时执行
{

    if((TIM3CH3_CAPTURE_STA&0X80)==0)//还未成功捕获
    {
        if(TIM3CH3_CAPTURE_STA&0X40)//已经捕获到高电平了
        {
            if((TIM3CH3_CAPTURE_STA&0X3F)==0X3F)//高电平太长了
            {
                TIM3CH3_CAPTURE_STA|=0X80;		//标记成功捕获了一次
                TIM3CH3_CAPTURE_VAL=0XFFFFFFFF;
            }
            else TIM3CH3_CAPTURE_STA++;
        }
    }
}


 uint32_t timecount,test,timecount1,fq;
 unsigned char state;

//定时器输入捕获中断处理回调函数，该函数在HAL_TIM_IRQHandler中会被调用
void TIM3CaptureChannel3Callback()//捕获中断发生时执行
{
    /*	if((TIM3CH3_CAPTURE_STA&0X80)==0)//还未成功捕获
    	{
    		if(TIM3CH3_CAPTURE_STA&0X40)		//捕获到一个下降沿
    			{
    				TIM3CH3_CAPTURE_STA|=0X80;		//标记成功捕获到一次高电平脉宽
                    TIM3CH3_CAPTURE_VAL=HAL_TIM_ReadCapturedValue(&TIM3_Handler,TIM_CHANNEL_3);//获取当前的捕获值.
                    TIM_RESET_CAPTUREPOLARITY(&TIM3_Handler,TIM_CHANNEL_1);   //一定要先清除原来的设置！！
                    TIM_SET_CAPTUREPOLARITY(&TIM3_Handler,TIM_CHANNEL_1,TIM_ICPOLARITY_RISING);//配置TIM5通道1上升沿捕获
    			}else  								//还未开始,第一次捕获上升沿
    			{
    				TIM3CH3_CAPTURE_STA=0;			//清空
    				TIM3CH3_CAPTURE_VAL=0;
    				TIM3CH3_CAPTURE_STA|=0X40;		//标记捕获到了上升沿
    				__HAL_TIM_DISABLE(&TIM3_Handler);        //关闭定时器5
    				__HAL_TIM_SET_COUNTER(&TIM3_Handler,0);
    				TIM_RESET_CAPTUREPOLARITY(&TIM3_Handler,TIM_CHANNEL_3);   //一定要先清除原来的设置！！
    				TIM_SET_CAPTUREPOLARITY(&TIM3_Handler,TIM_CHANNEL_3,TIM_ICPOLARITY_FALLING);//定时器5通道1设置为下降沿捕获
    				__HAL_TIM_ENABLE(&TIM3_Handler);//使能定时器5
    			}
    	}*/



    {
        TIM_RESET_CAPTUREPOLARITY(&TIM3_Handler,TIM_CHANNEL_3);   //一定要先清除原来的设置！！
        //清除中断标志位
        if(state==0)    //捕获第一个上升沿
        {
            state=1;
            timecount=HAL_TIM_ReadCapturedValue(&TIM3_Handler,TIM_CHANNEL_3); 	   //记录第一次上升沿的CNT值
        }
        else if(state==1)//捕获第二个上升沿
        {
            state=0;
            timecount1=HAL_TIM_ReadCapturedValue(&TIM3_Handler,TIM_CHANNEL_3);   //记录第二次上升沿的CNT值
            if(timecount<timecount1)
            {
                test=timecount1-timecount; 		  //两次上升沿的差值
            }
            else if(timecount>timecount1)
            {
                test=(0xffff-timecount)+timecount1;  //两次上升沿的差值
            }
            else
                test=0;
			uint32_t result;
			result = filter2(test);
            if(result!=NULL) 
            	fq=1000000/result;					  //脉冲的频率
            else
				fq = -1;
        }
    }
}
float GetCapture()
{

	return fq;

}
void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
    if(htim->Instance == TIM3)
    {
        if(htim->Channel==HAL_TIM_ACTIVE_CHANNEL_3)
        {
            TIM3CaptureChannel3Callback();
        }
    }
}

