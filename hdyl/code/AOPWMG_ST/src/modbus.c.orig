#include "modbus.h"
#include "crc.h"
#include "sensor.h"
unsigned char Modbus_03_Solve(void);
unsigned char Modbus_06_Solve(void);
unsigned char Modbus_16_Solve(void);

modbus_stru modbus_usr;
extern UART_HandleTypeDef huart6;
unsigned int startRegAddr;
unsigned int RegNum;
unsigned int calCRC;
//modbus_pack_stru  modbus_pack_usr;

void RS485_Init()
{

    HAL_GPIO_WritePin(EN1_485_GPIO_Port, EN1_485_Pin, GPIO_PIN_RESET);
    modbus_usr.RS485_TX_EN=0;//默认为接收模式
    __HAL_UART_CLEAR_IDLEFLAG(&huart6);
    __HAL_UART_DISABLE_IT(&huart6, UART_IT_IDLE);	//使能空闲中断
    HAL_UART_DMAStop(&huart6);
    HAL_UART_DMAResume(&huart6);
    __HAL_UART_ENABLE_IT(&huart6, UART_IT_IDLE);	//使能空闲中断
    HAL_UART_Receive_DMA(&huart6,modbus_usr.RS485_RX_BUFF,MODBUS_BSIZE);
}
//////////////////////////////////////////////////////////////////////////////
//发送n个字节数据
//buff:发送区首地址
//len：发送的字节数
void RS485_SendData(u8 *buff,u8 len,unsigned char flag)
{

    if(flag == 0)
        HAL_GPIO_WritePin(EN1_485_GPIO_Port, EN1_485_Pin, GPIO_PIN_SET);;
    modbus_usr.RS485_TX_EN=1;//切换为发送模式
    HAL_UART_Transmit(&huart6,buff,len,300);
    HAL_GPIO_WritePin(EN1_485_GPIO_Port, EN1_485_Pin, GPIO_PIN_RESET);
}
void Modbus_Pack(modbus_pack_stru p)
{
    if(p.startaddr == 0x07||p.startaddr == 0x08||p.startaddr == 0x16||
            p.startaddr == 0x19||p.startaddr == 0x1a||p.startaddr == 0x1b||
            p.startaddr == 0x34||p.startaddr == 0x36||p.startaddr == 0x38||
            p.startaddr == 0x3e||p.startaddr == 0x3f||p.startaddr == 0x66)
        p.datType =UINT_TYPE;
    else
        p.datType = FLOAT_TYPE;

    unsigned char index;
	index = 0;



	if(p.func == 0x03)
	{
	  	modbus_usr.RS485_TX_BUFF[index++]=p.RS485_Addr;
	modbus_usr.RS485_TX_BUFF[index++]=p.func;
	modbus_usr.RS485_TX_BUFF[index++]=(u8)(p.startaddr>>8);
	modbus_usr.RS485_TX_BUFF[index++]=(u8)(p.startaddr);  
	modbus_usr.RS485_TX_BUFF[index++]=(u8)(p.regnum>>8);
	modbus_usr.RS485_TX_BUFF[index++]=(u8)(p.regnum);		
	}
	else
	{
		if(p.datType == FLOAT_TYPE)
		{
	  	modbus_usr.RS485_TX_BUFF[index++]=p.RS485_Addr;
	modbus_usr.RS485_TX_BUFF[index++]=p.func;
	modbus_usr.RS485_TX_BUFF[index++]=(u8)(p.startaddr>>8);
	modbus_usr.RS485_TX_BUFF[index++]=(u8)(p.startaddr);  
	modbus_usr.RS485_TX_BUFF[index++]=(u8)(p.regnum>>8);
	modbus_usr.RS485_TX_BUFF[index++]=(u8)(p.regnum);				
		}
		else
		{
			modbus_usr.RS485_TX_BUFF[index++]=p.RS485_Addr;
		modbus_usr.RS485_TX_BUFF[index++]=p.func;
		modbus_usr.RS485_TX_BUFF[index++]=(u8)(p.startaddr>>8);
		modbus_usr.RS485_TX_BUFF[index++]=(u8)(p.startaddr); 

		}
	}

    unsigned char len;
    len = 6;
    if(p.datcount)
    {
        modbus_usr.RS485_TX_BUFF[index++]=(u8)(p.datcount);
        memcpy(&modbus_usr.RS485_TX_BUFF[index++],p.modbus_txdata,p.datcount);
        len = len + p.datcount+1;

    }
    else
    {

        calCRC=CRC_Compute(modbus_usr.RS485_TX_BUFF,len);
        modbus_usr.RS485_TX_BUFF[len+1]=(calCRC)&0xFF;
        modbus_usr.RS485_TX_BUFF[len+2]=(calCRC>>8)&0xFF;
    }


    RS485_SendData(modbus_usr.RS485_TX_BUFF,len+2,0);
}

/*************************************************************
485串口接收中断回调函数
*************************************************************/
void RS485_RxCpltCallback()
{
    modbus_usr.RS485_FrameFlag=2;//置位帧结束标记
    HAL_UART_DMAStop(&huart6);
    HAL_UART_DMAResume(&huart6);
    HAL_UART_Receive_DMA(&huart6,modbus_usr.RS485_RX_BUFF,MODBUS_BSIZE);
}
/////////////////////////////////////////////////////////////////////////////////////
//RS485服务程序，用于处理接收到的数据(请在主函数中循环调用)

unsigned char RS485_Service(void)
{
    u16 recCRC;
    if(modbus_usr.RS485_FrameFlag==2)
    {
        HAL_GPIO_WritePin(EN1_485_GPIO_Port, EN1_485_Pin, GPIO_PIN_RESET);
        if(modbus_usr.RS485_RX_BUFF[0]>= MIN_ADDR &&
                modbus_usr.RS485_RX_BUFF[0]<= MAX_ADDR)//地址正确
        {
            if((modbus_usr.RS485_RX_BUFF[1]==03)||(modbus_usr.RS485_RX_BUFF[1]==06)||(modbus_usr.RS485_RX_BUFF[1]==16))//功能码正确
            {
                modbus_usr.RS485_RX_CNT = modbus_usr.RS485_RX_BUFF[2]+5;
                calCRC=CRC_Compute(modbus_usr.RS485_RX_BUFF,modbus_usr.RS485_RX_CNT-2);//计算所接收数据的CRC
                recCRC=modbus_usr.RS485_RX_BUFF[modbus_usr.RS485_RX_CNT-2]|(((u16)modbus_usr.RS485_RX_BUFF[modbus_usr.RS485_RX_CNT-1])<<8);//接收到的CRC(低字节在前，高字节在后)
                if(calCRC==recCRC)//CRC校验正确
                {
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    switch(modbus_usr.RS485_RX_BUFF[1])//根据不同的功能码进行处理
                    {
                    case 3: //读寄存器
                    {
                        Modbus_03_Solve();
                        break;
                    }
                    case 6: //读寄存器
                    {
                        Modbus_06_Solve();
                        break;
                    }

                    case 16: //读寄存器
                    {
                        Modbus_16_Solve();
                        break;
                    }



                    }
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                }

            }
        }
    }
    return 1;

}

unsigned char Modbus_03_Solve()
{
    unsigned char result;

    if(GetModbusPack()->datType == FLOAT_TYPE)
    {
        if(modbus_usr.RS485_RX_BUFF[2] == 4)
        {
            GetModbusPack()->modbus_data[0] = modbus_usr.RS485_RX_BUFF[5];
            GetModbusPack()->modbus_data[1] = modbus_usr.RS485_RX_BUFF[6];
            GetModbusPack()->modbus_data[2] = modbus_usr.RS485_RX_BUFF[3];
            GetModbusPack()->modbus_data[3] = modbus_usr.RS485_RX_BUFF[4];
            result = 0;
        }
        else
            result = 1;
    }
    else
    {
        if(modbus_usr.RS485_RX_BUFF[2] == 2)
        {
            GetModbusPack()->modbus_data[0] = modbus_usr.RS485_RX_BUFF[3];
            GetModbusPack()->modbus_data[1] = modbus_usr.RS485_RX_BUFF[4];
            result = 0;
        }
        else
            result = 1;
    }
    return result;

}

unsigned char Modbus_06_Solve()
{
    return 1;
}
unsigned char Modbus_16_Solve()
{
    return 1;

}
