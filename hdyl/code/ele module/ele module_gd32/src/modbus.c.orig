#include "modbus.h"
#include "crc.h"
//#include "sensor.h"
unsigned char Modbus_03_Solve(void);
unsigned char Modbus_06_Solve(void);
unsigned char Modbus_16_Solve(void);

modbus_stru modbus_usr;
modbus_pack_stru modbus_pack_usr;
#if CPU == ST
extern UART_HandleTypeDef huart1;
#endif
unsigned int startRegAddr;
unsigned int RegNum;
unsigned int calCRC;
//modbus_pack_stru  modbus_pack_usr;

void RS485_Init()
{
#if CPU == ST
    HAL_GPIO_WritePin(EN1_485_GPIO_Port, EN1_485_Pin, GPIO_PIN_RESET);
    modbus_usr.RS485_TX_EN=0;//默认为接收模式
    __HAL_UART_CLEAR_IDLEFLAG(&huart1);
    __HAL_UART_DISABLE_IT(&huart1, UART_IT_IDLE);	//使能空闲中断
    HAL_UART_DMAStop(&huart1);
    HAL_UART_DMAResume(&huart1);
    __HAL_UART_ENABLE_IT(&huart1, UART_IT_IDLE);	//使能空闲中断
    HAL_UART_Receive_DMA(&huart1,modbus_usr.RS485_RX_BUFF,MODBUS_BSIZE);
	#endif
	modbus_usr.RS485_Addr = 0x05;

}
//////////////////////////////////////////////////////////////////////////////
//发送n个字节数据
//buff:发送区首地址
//len：发送的字节数
void RS485_SendData(uint8_t *buff,uint8_t len,unsigned char flag)
{
	 unsigned char i;
  #if CPU == ST
    if(flag == 0)
        HAL_GPIO_WritePin(EN1_485_GPIO_Port, EN1_485_Pin, GPIO_PIN_SET);;
    modbus_usr.RS485_TX_EN=1;//切换为发送模式
    HAL_UART_Transmit(&huart1,buff,len,300);
    HAL_GPIO_WritePin(EN1_485_GPIO_Port, EN1_485_Pin, GPIO_PIN_RESET);
		#else
		   i=0;
	gpio_bit_write(EN1_485_GPIO_Port, EN1_485_Pin, SET);
   while(i<len)
	 {
		 usart_data_transmit(USART0, buff[i++]);
	  while(RESET == usart_flag_get(USART0, USART_FLAG_TBE));
	 }
	 delay_ms(5);
	 gpio_bit_write(EN1_485_GPIO_Port, EN1_485_Pin, RESET);
	#endif
}
void Modbus_Pack(modbus_pack_stru *p)
{
unsigned char len;
    unsigned char index;
    index = 0;



    if(p->func == 0x03)
    {
        modbus_usr.RS485_TX_BUFF[index++]=p->RS485_Addr;
        modbus_usr.RS485_TX_BUFF[index++]=p->func;
        modbus_usr.RS485_TX_BUFF[index++]=p->payload_len;
       // modbus_usr.RS485_TX_BUFF[index++]=0;
        memcpy(&modbus_usr.RS485_TX_BUFF[index],p->modbus_txdata,2);
			index =index+2;

    }
    else
    {
        modbus_usr.RS485_TX_BUFF[index++]=p->RS485_Addr;
        modbus_usr.RS485_TX_BUFF[index++]=p->func;
        modbus_usr.RS485_TX_BUFF[index++]=(uint8_t)(p->startaddr>>8);
        modbus_usr.RS485_TX_BUFF[index++]=(uint8_t)(p->startaddr);
        // modbus_usr.RS485_TX_BUFF[index++]=0;
        memcpy(&modbus_usr.RS485_TX_BUFF[index],p->modbus_txdata,2);
			index =index+2;
    }

    
    len = index;
    {

        calCRC=CRC_Compute(modbus_usr.RS485_TX_BUFF,len);
        modbus_usr.RS485_TX_BUFF[len+1]=(calCRC)&0xFF;
        modbus_usr.RS485_TX_BUFF[len]=(calCRC>>8)&0xFF;
    }


    RS485_SendData(modbus_usr.RS485_TX_BUFF,len+2,0);
}

/*************************************************************
485串口接收中断回调函数
*************************************************************/
void RS485_RxCpltCallback()
{

//		dma_parameter_struct dma_data_parameter;
//	   dma_parameter_struct dma_init_struct;
    modbus_usr.RS485_FrameFlag=2;//置位帧结束标记
	#if CPU == ST
    HAL_UART_DMAStop(&huart1);
    HAL_UART_DMAResume(&huart1);
    HAL_UART_Receive_DMA(&huart1,modbus_usr.RS485_RX_BUFF,MODBUS_BSIZE);
	#else
	        modbus_usr.RS485_RX_CNT= MODBUS_BSIZE - (dma_transfer_number_get(DMA0, DMA_CH4));
	        dma_channel_disable(DMA0, DMA_CH4);
        dma_transfer_number_config(DMA0, DMA_CH4, MODBUS_BSIZE);
        dma_channel_enable(DMA0, DMA_CH4);
	#endif
}
/////////////////////////////////////////////////////////////////////////////////////
//RS485服务程序，用于处理接收到的数据(请在主函数中循环调用)
modbus_pack_stru *GetModbusPack()
{
    return  &modbus_pack_usr;
}
modbus_stru *GetModbusPayLoad()
{
    return  &modbus_usr;
}

unsigned char RS485_Service(void)
{
    uint16_t recCRC;
	unsigned char result;
	result = 1;
    if(modbus_usr.RS485_FrameFlag==2)
    {
			  #if CPU == ST
        HAL_GPIO_WritePin(EN1_485_GPIO_Port, EN1_485_Pin, GPIO_PIN_RESET);
			#endif
        if(modbus_usr.RS485_RX_BUFF[0] == modbus_usr.RS485_Addr)//地址正确
        {
            if((modbus_usr.RS485_RX_BUFF[1]==03)||(modbus_usr.RS485_RX_BUFF[1]==06)||(modbus_usr.RS485_RX_BUFF[1]==16))//功能码正确
            {
                modbus_usr.RS485_RX_CNT = 8;
                calCRC=CRC_Compute(modbus_usr.RS485_RX_BUFF,modbus_usr.RS485_RX_CNT-2);//计算所接收数据的CRC
                recCRC=modbus_usr.RS485_RX_BUFF[modbus_usr.RS485_RX_CNT-1]|(((uint16_t)modbus_usr.RS485_RX_BUFF[modbus_usr.RS485_RX_CNT-2])<<8);//接收到的CRC(低字节在前，高字节在后)
				if(calCRC==recCRC)//CRC校验正确
                {

                    if(modbus_usr.RS485_RX_BUFF[3] == 0x07||modbus_usr.RS485_RX_BUFF[3] == 0x08|modbus_usr.RS485_RX_BUFF[3] == 0x16||
                            modbus_usr.RS485_RX_BUFF[3] == 0x19||modbus_usr.RS485_RX_BUFF[3] == 0x1a||modbus_usr.RS485_RX_BUFF[3] == 0x1b||
                            modbus_usr.RS485_RX_BUFF[3] == 0x34||modbus_usr.RS485_RX_BUFF[3] == 0x36||modbus_usr.RS485_RX_BUFF[3] == 0x38||
                            modbus_usr.RS485_RX_BUFF[3] == 0x3e||modbus_usr.RS485_RX_BUFF[3] == 0x3f||modbus_usr.RS485_RX_BUFF[3] == 0x66||
                            (modbus_usr.RS485_RX_BUFF[3] >= 0x40&&modbus_usr.RS485_RX_BUFF[3] <= 0x45))
                        GetModbusPack()->datType =UINT_TYPE;
                    else
                        GetModbusPack()->datType = FLOAT_TYPE;

                    modbus_pack_usr.func = modbus_usr.RS485_RX_BUFF[1];

                    modbus_pack_usr.startaddr =  modbus_usr.RS485_RX_BUFF[2];
                    modbus_pack_usr.startaddr =  modbus_pack_usr.startaddr<<8;
                    modbus_pack_usr.startaddr =  modbus_pack_usr.startaddr+modbus_usr.RS485_RX_BUFF[3];


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    switch(modbus_usr.RS485_RX_BUFF[1])//根据不同的功能码进行处理
                    {
                    case 3: //读寄存器
                    {
                        result=Modbus_03_Solve();
                        break;
                    }
                    case 6: //写寄存器
                    {
                        result=Modbus_06_Solve();
                        break;
                    }
                    }
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                }

            }
        }
    }
		modbus_usr.RS485_FrameFlag=0;
    return result;

}
//return  0                                  2             3
//       orp or ph or temperature      warn or adc
unsigned char Modbus_03_Solve()
{
    unsigned char result;

    if(GetModbusPack()->datType == UINT_TYPE)
    {

        GetModbusPack()->datType = UINT_TYPE;
        GetModbusPack()->modbus_data[0] = modbus_usr.RS485_RX_BUFF[2];
        GetModbusPack()->modbus_data[1] = modbus_usr.RS485_RX_BUFF[3];
        result = 2;
    }
    else
        result = 1;
    return result;

}

unsigned char Modbus_06_Solve()
{
    unsigned char result;

    if(GetModbusPack()->datType == UINT_TYPE)
    {

        // GetModbusPack()->datType = UINT_TYPE;
        GetModbusPack()->modbus_data[0] = modbus_usr.RS485_RX_BUFF[4];
        GetModbusPack()->modbus_data[1] = modbus_usr.RS485_RX_BUFF[5];
        result = 3;
    }
    else
        result = 1;
    return result;

}
unsigned char Modbus_16_Solve()
{
    return 1;

}
